; Compile with :
; acme wiz.a
; dskalyzer.exe -with-disk BAD_APPLE.DSK -file-put wiz3#0x0C00.o
; wine-development ~/.wine/drive_c/Program\ Files\ \(x86\)/faddenSoft/CiderPress/CiderPress.exe
; mame apple2p -skip_gameinfo -window -nomax -flop1 NEW.DSK -flop2 cstripes.dsk
; c:\port-stc\opt\mame\mame64 apple2p -skip_gameinfo -window -nomax -flop1 NEW.DSK -flop2 cstripes.dsk -rp bios

; mame apple2p  -skip_gameinfo -window -nomax -flop1 NEW.DSK -flop2 cstripes.dsk -aviwrite z.avi
;  ffmpeg -i ~/.mame/snap/z.avi -vf "scale=iw*.5:ih,format=gray" o.avi

;; java -jar ~/Downloads/AppleCommander-1.3.5.13-ac.jar -d NEW.DSK STARTUP
;; java -jar ~/Downloads/AppleCommander-1.3.5.13-ac.jar -p NEW.DSK STARTUP BIN 0x0C00 < STARTUP


; 1 side x 35 Tracks/side x 16 Sectors/Trk x 256 Bytes/Sec = 143,360 Bytes.
; 2200 pictures => 2200/35=62 frames per track


	!cpu 6502
	!sl "listing.txt"
	!to "STARTUP",plain

 	;; !to "STARTUP#060C00",plain		; The stuff at '#' is for CiderPress to
       	;;    				; set up file attributes : 06=BIN file,
	;; 				; 0C00 = load address in RAM

;       to "wiz3#0x0C00.o",plain		; The stuff at '#' is for Diskalayzer to
;       	   				; set up file attributes : 06=BIN file,
;					; 0C00 = load address in RAM



; My goal is to use the Apple Drive as a timer.  It produces a « tick
; » each time a sector is read. Reading a sector is 0.  Drive is 300
; RPM, so 5 RPS, since there are 16 sectors per track, that’s 80
; sectors per second => 1 sector = 0.0125 second = 12500 cycles. So a tick every
; 0.0125 second.

; Since reading sectors and processing data must be interleaved and
; data processing is hard to estimate, I’ll track the number of sector
; « passed by » from time to time (instead of trying to « race » the
; disk on each sectors). This can be done using rdaddr16 which
; indicates the number of the sector it finds.

; Every 0.1 second, I need to display a frame of the
; video. Interestingly, 0.1 = 0.0125 (sector tick) * 8 => I need to
; display a frame of the video every 8 sectors.  Also, everytime I
; have read 16 sectors, I must advance one track. This action takes «
; some » time.

; I store at least one frame per sector. So I can read up to 8
; sectors while I display one frame.

; The problem is when there's one sector left to be read
; on a track. In that case, the worst case scenario is to pass
; 16-1=15 sectors before reaching the one we're interested in.
; If, for example, I do nothing while waiting, then that
; time is wasted. So the whole idea is to wait in a active maner.
; The best way to do that is to process some data and poll the
; drive from time to time to know if I'm close or not a sector
; I have to read. If I'm close, then I wait. If I'm far, then
; I process some more data an poll the drive later on.

; The difficulty of course is to estimate the time it takes
; to "process some data". I'll use heuristics in a first
; approach. I could count the cycles but that's very tricky.

; Read sector address
; how far is the next sector that must be read ?
; More than 2 sectors away : process some data.
; Less than 2 sectors away : wait for that sector, then read it.
; If sector_passed MOD 8 == 7 : time to show a frame.
; If all sectors are read, advance track.
; Process data = decompress stripes up to 4 frames ahead (1 frame in tiles = 40*48/4 = 480 tiles = 480 bytes); I decrunch one sector at a time

; Decrunching a frame takes 30000 cycles so far, reading a sectors
; takes +/- 12500 cycles => decrunching a full frames takes around 3
; sectors.

; Untiling and copying frames takes, say, 25000 cycles

; Imagine we work on a sector basis (harder because huffman encodes
; stuff that can be on both sides of sector boundaries)

; halfTrack = 8 sectors
; halfTrack[i] == 0 : to read, 2 : to process, 1 : processed
; when sum(halfTrack) >= 1* len(halfTrack) : start reading sector on another halfTrack (if other halfTrack is ready to read)
; when sum(halfTrack) == 2* len(halfTrack) : mark this half track ready to read (reset statuses to 0).

; processed_half_track; read_halftrack



!macro add_a_to_16 .target {
        ; Add A to .target
	; A is destroyed
        CLC			; 2 c
	ADC .target		; 3 zp or 4 absolute
	STA .target		; 3 zp or 4 absolute
	LDA #0			; 2
	ADC .target + 1		; 3 or 4
	STA .target + 1		; 3 or 4 => 16 or 20 cycles
}


; increase 16-bit counters
; no register touched
!macro inc16 .target {
	inc .target					; 5+
	bne .j	; "bne * + 5" would not work in zp	; 2+
	inc .target + 1	      	    	     		; 5+ => total 12 or 15 cycles
.j
}

; decrease 16-bit counters
; A destroyed
!macro dec16 .target {
	LDA .target
	BNE .j	; "bne * + 5" would not work in zp
	DEC .target + 1
.j
	DEC .target	; low byte
}


!macro store_16 .target, .const {
	lda #<.const
	sta .target
	lda #>.const
	sta .target + 1
}

!macro store_8 .target, .const {
	lda #.const
	sta .target
}

; 16 bit word := 16 bit word - 16 bit const
!macro sub_const_from_16 .target, .const {
	SEC
	LDA .target
	SBC #<.const
	STA .target
	LDA .target + 1
	SBC #>.const
	STA .target + 1
}

; 16 bit word := 16 bit word + 16 bit const
!macro add_const_to_16 .target, .const {
	CLC
	LDA .target     ; low byte
	ADC #<.const
	STA .target

	LDA .target+1	; high byte
	ADC #>.const
	STA .target+1
}


!macro	writeln .msg {
	LDA #(< .msg)
       	STA println_self_mod + 1
       	LDA #(> .msg)
       	STA println_self_mod + 2
	JSR println
}

DRAW_STATUS = 1
LZ	= 1
NOCOMP	= 0
compression = LZ		; LZ or NOCOMP
TOTAL_FRAMES	= 2190		; Number of frames in the movie
TRANSPARENT_TILE	= $7E
VERTICAL_TILES = 20
HORIZONTAL_TILES = 24


GETLNZ 		= $FD67
GETLNZ_PROMPT 	= $33
COUT     	= $FDED	; The Apple II character output func.
GR_RAM	 	= $400
GR2_RAM	 	= $800
HGR_RAM		= $2000
MLI		= $BF00
SPKR		= $C030
MOTOR_ON	= $C089
DRV_ENABLE	= $C08A		; Select drive 1
DRV2_SLCT	= $C08B		; Select drive 2
LC_RAM_SELECT	= $C08B

DRIVE_SELECT	= $80	; 0 == drive 1; $80 = drive 2
SLOT_SELECT	= $60	; 0 (drive 1) 110 (slot 6) 0000
PRODOS_MLI_READ	= $CA
PRODOS_MLI_OPEN	= $C8

TRACKS_PER_SIDE		= 35
BYTES_PER_SECTOR 	= 256
SECTORS_PER_TRACK 	= 16


; Zero page locations
; -------------------

end_hgr_line_pointer  = 220
hgr_tile		= 222
pointer		    	= 224
pointer2		= 226
;; lo_hi_bits_reverse_ptr	= 226
stripe_ptr		= 228
tile_pointer		= 230
stripe_index		= 232
count1			= 234
count2			= 235
count3			= 236
remaining_bytes_on_line = 236
command_byte		= 238
line_split		= 239
expand_pixels_table1_ptr = 240
expand_pixels_table2_ptr = 242
rle_pointer	 	 = 244

screen_pointer	 	 = 246

cmd_pointer	 	 = 248
screen_line_ptr 	 = 250

screen_pointer_plus_one  = 252
filler_ptr		 = 252
dummy_ptr		= 254

; Other constants

disk_buffers_base	= $DE00	; you'll need 64kb RAM to do that (language card!)

; Prodos stuff

wtemp            =        $3a
midnib1          =        wtemp+1
midnib2          =        wtemp+2
lstnib           =        wtemp+3
slotz            =        wtemp + 4
yend             =        wtemp+5
buf              =        $44



	*= $C00







	+store_8 rs_sectors_to_read, 100
	+store_8 target_track, 27
	+store_8 target_sector, 15
	+store_8 target_bank, $40
	jsr read_sect

	LDA #(' '+$80)
	JSR clear_screen
	+writeln msg
	LDA #('>' + $80)
	STA GETLNZ_PROMPT
!if DRIVE_SELECT = 0 {
	JSR GETLNZ
}
	;; JSR set_gr_mode


	;; Activate 64k in read/write mode
	LDA LC_RAM_SELECT
	LDA LC_RAM_SELECT

	+store_8 rs_sectors_to_read, 17
	+store_8 target_track, 33
	+store_8 target_sector, 15
	+store_8 target_bank, >(disk_buffers_base+2*SECTORS_PER_TRACK*BYTES_PER_SECTOR-16*256)
	jsr read_sect


	+store_16 pointer, disk_buffers_base+2*SECTORS_PER_TRACK*BYTES_PER_SECTOR-16*256
	jsr init_preload

zgood:

	;; +store_16 pop_path, datafile
	;; JSR MLI
	;; !byte PRODOS_MLI_OPEN
	;; !word prodos_open_params	    ; $0E0C

	;; LDA pop_ref
	;; STA prp_ref
	;; +store_16 prp_adr, $4000
	;; JSR MLI
	;; !byte PRODOS_MLI_READ	; Operation ($80=READ_BLOCK, $81=write)
	;; !word prodos_read_params	    ; $0E0C

	JMP zorglub
	;; JMP main_start

prodos_params:
	!byte 3	; 3 parameters
	!byte SLOT_SELECT + DRIVE_SELECT
	!word GR2_RAM ; Memory buffer, make sure it's not in ProDos's stuff
block_read	!word $0001 ; Block to read

prodos_read_params:
	!byte 4
prp_ref	!byte 0
prp_adr	!word 0
prp_len	!word 4096
prp_alen	!word 0


prodos_open_params:
	!byte 3
pop_path	!word 0
pop_buffer	!word $9A00
pop_ref	!byte 0

datafile	!byte 6
		!text "BADATA"

next_track_trigger	!byte 64
next_read_sector	!byte 32
current_sector !byte 0
stripe_n       !byte 0

track_seek_countdown_value	= 10
track_seek_countdown !byte track_seek_countdown_value

; ####################################################################
; ### MAIN START
; ####################################################################
hgr_tile_data:
	;;  lo bits are aligned on the left
	!byte 255,127,63,31,15,7,3,1
	!byte 255,255,255,255,255,255,255,255
	!byte 255,255,255,255,0,0,0,0
	!byte %00111110
	!byte %01000011
	!byte %01000101
	!byte %01001001
	!byte %01010001
	!byte %01100001
	!byte %01010001
	!byte %00111110

tiles_hgr:
	!for i,127 {
	!word tiles + (i-1)*8 - 1
	}

hgr_strip:
	!byte 0,1,2,3,2,1,0,0,1,2,3,2,1,0,0,1,2,3,2,1,0,0,1,2,3,2,1,0,0,1,2,3,2,1,0

	CENTERING = (40 - HORIZONTAL_TILES) >> 1

hgr_lines_offsets:
	!for i,8 {
	!word HGR_RAM + (i-1)*$80 + CENTERING
	}
	!for i,8 {
	!word HGR_RAM + $28 + (i-1)*$80  + CENTERING
	}
	!for i,8 {
	!word HGR_RAM + $50 + (i-1)*$80  + CENTERING
	}


!macro setup_hgr_line_pointers {
	;; Compute beginnig and end of the first line of the tile on the screen
	LDA hgr_current_line	; From 0 to 23 (x8 to have pixels => 0-184)
	ASL			; bit 7 shifted into carry; sinc evalue is small, carry is cleared
	TAY
	;; The hi-byte of count determines the line; the low byte gives offset in the line
	LDA hgr_lines_offsets,Y
	STA screen_pointer
	LDA hgr_lines_offsets + 1,Y
	STA screen_pointer + 1

	;;  Compute the end of the line
	LDA hgr_lines_offsets,Y
	CLC			; FIXME useless
	ADC #HORIZONTAL_TILES			; 40*7 = 280 pixels
	STA end_hgr_line_pointer

	}


!macro advance_screen_pointers_right {
	!zone {
	;;  Next tile (on screen)
	clc
	lda screen_pointer
	adc #1
	sta screen_pointer

	cmp end_hgr_line_pointer
	bne .still_in_line
	inc hgr_current_line

	+setup_hgr_line_pointers

.still_in_line:
	}
	}

current_offset	!word $2020	;32
hgr_current_line	!byte 3
hgr_line_end	!word  $2028
stripe_len	!byte 12
scount1		!byte 0
scount2		!byte 0


;; main_start:

;; 	jsr set_hgr_mode
;; 	jsr clear_screen
;; 	jsr clear_hgr

;; 	lda #0
;; 	sta hgr_current_line
;; 	+store_16 stripe_ptr, hgr_strip
;; 	+setup_hgr_line_pointers

;; 	LDA screen_pointer
;; 	ADC #30
;; 	STA screen_pointer

;; 	LDA #10+3
;; 	STA count3

;; .hgr_tile_loop1:
;; 	LDY count3
;; 	LDA (stripe_ptr),Y	; From tile number...
;; 	ASL

;; 	LDA #$FF
;; 	JSR hgr_mono_tile_expander
;; 	;; JSR hgr_tile_expander


;; 	DEC count3
;; 	BNE .hgr_tile_loop1

;; 	JSR GETLNZ
;; 	JMP zorglub




;; ;;  ---------------------------------------------------------------------

;; 	;;  Split stripe if necessary

;; 	lda current_offset 			; tiles to write
;; 	clc
;; 	adc stripe_len

;; 	cmp hgr_line_end
;; 	bmi no_split

;; 	; current_ofs + stripe_len < hgr_line_end

;; 	;; eor #$FF
;; 	;; clc
;; 	;; adc #$1

;; 	lda stripe_len
;; 	sta count1
;; 	lda #0
;; 	sta count2

;; no_split:
;; 	lda hgr_line_end
;; 	sec
;; 	sbc current_offset
;; 	sta count1

;; 	lda stripe_len
;; 	sec
;; 	sbc count1
;; 	sta count2


;;  ---------------------------------------------------------------------


zorglub:
	;; jsr load_current_stripe

;; 	jsr read_bits
;; 	clc
;; 	inc debug
;; 	lda #$EE
;; 	cmp debug
;; 	bne zorglub
;; 	lda pointer
;; 	lda pointer + 1
;; 	rol data
;; 	rol data + 1
;; 	jmp zorglub
;; debug	!byte 0


	lda #' '+$80
	jsr clear_screen
	jsr clear_hgr
	jsr set_hgr_mode

	;; LDA #0
	;; JSR clear_screen
	;; JSR init_disk_read

	!if DRIVE_SELECT = $80 {
	LDX #SLOT_SELECT
	LDA DRV2_SLCT, X
	}

	LDA #SLOT_SELECT
	JSR sector_zero


	LDA #0
	STA hgr_current_line

	+store_16 screen_pointer, HGR_RAM
	+setup_hgr_line_pointers

	jmp main_control


;  ----------------------------------------------------------------------------

TRACK_DATA_BANK = disk_buffers_base >> 8
TRACK_DATA_BANK_OUT = (disk_buffers_base+2*SECTORS_PER_TRACK*BYTES_PER_SECTOR) >> 8

stay_on_first_track	!byte 0
read_disk_delay !byte 0
track_buffer	!byte 0 ; (0 or 16) Track buffer being read into
track_status !fill SECTORS_PER_TRACK*2,0
sectors_to_read	   !byte SECTORS_PER_TRACK


main_control:

	;; jsr preload_sectors
	;; jsr copy_compressed


.main_control_loop:
!if DRAW_STATUS = 1 {
	jsr draw_status
}
	ldx #SLOT_SELECT
	jsr rdadr16
	bcs .main_control_loop	 ; Cheap retry

	;; From now on, time is ticking, we must do
	;; as much as we can before the read latch
	;; comes on the sector data.

	; Decide what to do next

PAUSE = 6
	LDA sectors_passed
	CMP #PAUSE	; Decrunching a picture takes up to 4 sectors "long". With this timeing, I reach roughly 3min 40s which is the time we look for.
	BMI .noframe
	SEC
	SBC #PAUSE
	STA sectors_passed


	; Read a sector before drawing, else we always miss that sector
	; because the synchronisation with the disk is very clean

	jsr read_sector_if_necessary

	jsr process_a_frame

	jmp .main_control_loop

.noframe:
	lda sectors_to_read
	cmp #0
	beq .wait_processing

	lda sect
	clc
	adc track_buffer
	tay
	LDA track_status,Y
	CMP #0	; Sector is yet to be read
	beq .read_a_sector
	bne .main_control_loop

.read_a_sector:
	jsr read_any_sector
	bcs .main_control_loop

.wait_processing:

	jsr change_track_if_necessary

.unexpected_sector:
	jmp .main_control_loop

.error:
	RTS



read_unread_sector:
	!zone {
	ldx #SLOT_SELECT
	jsr rdadr16
	bcs .error

read_sector_if_necessary:
	lda sect
	clc
	adc track_buffer
	tay

	lda track_status, Y
	cmp #0
	beq read_any_sector
	rts

read_any_sector:

	;; lda read_disk_delay
	;; cmp #0
	;; bne .success


	; Prepare RWTS buffer

	lda #0
	sta buf

	lda sect
	clc
	adc track_buffer
	clc
	adc #TRACK_DATA_BANK
	sta buf + 1

	; Read the sector

	ldx #SLOT_SELECT
	jsr read16
	bcs .error


	lda sect
	clc
	adc track_buffer
	tay

	; Defensive programming

	lda track_status, Y
	cmp #0
	bne .error ; unexpected sector

	; mark sector as read

	lda #1
	sta track_status, Y

	dec sectors_to_read

!if compression = LZ {
	;;  Allow some wraping

	lda sect
	clc
	adc track_buffer
	cmp #0
	bne .no_wrap
	LDA TRACK_DATA_BANK << 8
	STA TRACK_DATA_BANK_OUT << 8
	LDA (TRACK_DATA_BANK << 8) + 1
	STA (TRACK_DATA_BANK_OUT << 8) + 1
	LDA (TRACK_DATA_BANK << 8) + 2
	STA (TRACK_DATA_BANK_OUT << 8) + 2
.no_wrap:
	}
.success:
	CLC
	RTS
.error:
	SEC
	RTS
	}
; ----------------------------------------------------------------------------
change_track_if_necessary:

	; Are all sectors read?

	lda sectors_to_read
	cmp #0
	bne .no_track_change

	; Are all other sectors processed ?

	lda track_buffer
	eor #SECTORS_PER_TRACK
	clc
	adc #TRACK_DATA_BANK
	clc
	adc #SECTORS_PER_TRACK	; first sector after the end of buffer

!if compression = LZ {
	cmp pointer + 1
} else {
	cmp stripe_index + 1
}
	bne .no_track_change

change_track:

	; Track advance and buffer swap

	jsr advance_drive_latch
	bcc track_advanced

	SEC
	RTS

track_advanced:

	;;  Set pointer (attenion! we only reset the pointer when at the end of BOTH the buffers)

	lda #TRACK_DATA_BANK_OUT
	cmp pointer + 1
	bne .not_at_end
	;; jsr huff_pointer_at_end
	;; bcc .not_at_end
	+sub_const_from_16 pointer, 2*SECTORS_PER_TRACK*BYTES_PER_SECTOR
.not_at_end:

	; switch track buffer

	lda track_buffer
	eor #SECTORS_PER_TRACK
	sta track_buffer

	lda #SECTORS_PER_TRACK
	sta sectors_to_read

	JSR clear_read_status

	; Set stripe index

	lda #0
	sta stripe_index

	lda track_buffer
	eor #SECTORS_PER_TRACK
	clc
	adc #TRACK_DATA_BANK
	sta stripe_index + 1




.no_track_change:
	CLC
	RTS

; ----------------------------------------------------------------------------

check_stripe_at_end:
	lda track_buffer
	eor #SECTORS_PER_TRACK
	clc
	adc #TRACK_DATA_BANK
	clc
	adc #SECTORS_PER_TRACK	; Last sector + 1 (ie one sector too far)
	cmp stripe_index + 1	; Hi byte of stripe index beacuse a sector is 256 bytes.
	beq .at_end
	CLC
	RTS
.at_end:
	SEC
	RTS

; ----------------------------------------------------------------------------

clear_read_status:
	!zone {
	lda #0
	ldy track_buffer
	ldx #0
.loop:
	sta track_status,y
	iny
	inx
	cpx #SECTORS_PER_TRACK
	bne .loop
	}

	rts

; ----------------------------------------------------------------------------

	!macro pixel {
	CMP #1
	BNE .not_read
	LDA #'-' + $80
	JMP .go_on
.not_read:
	LDA #'.' + $80
.go_on:

	}

!if DRAW_STATUS = 1 {

STATUS_BUFFER = $7D0	; $750 $650
STATUS_BUFFER2 = $750
STATUS_BUFFER3 = HGR_RAM  + $800


draw_status:
	;; Draw the track status

	lda #0
	ldy #0
draw_status0:
	LDA track_status, Y	; 0 or 1
	+pixel
	STA STATUS_BUFFER,Y

	INY
	CPY #SECTORS_PER_TRACK*2
	BNE draw_status0


	LDA #' ' + $80
draw_status1:
	STA STATUS_BUFFER, Y
	INY
	CPY #40
	BNE draw_status1


	LDY #0
draw_status2:
	TYA
	CMP #10
	BMI under10
	CLC
	ADC #'A'+$80 - 10
	jmp hexband
under10:
	CLC
	ADC #'0'+$80
hexband:
	STA STATUS_BUFFER2, Y
	INY
	CPY #SECTORS_PER_TRACK
	BNE draw_status2


	;;  Draw the memory pointer


	LDA pointer+1
	SEC
	SBC #TRACK_DATA_BANK

	TAY
	LDA #$0D		; M inverse
	;; ORA STATUS_BUFFER2,Y
	STA STATUS_BUFFER,Y

	;; Draw the disk head

	lda sect
	clc
	adc track_buffer
	tay
	lda STATUS_BUFFER,Y
	and #$7F		; flashing
	sta STATUS_BUFFER,Y

	;; Draw the skipped sectors

	;; lda sectors_passed
	;; tay
	;; lda #%01110101
	;; sta STATUS_BUFFER3,Y
	RTS
}

; ----------------------------------------------------------------------------

; -----------------------------------------------------------------------------


;; end_picture_reached  !byte 0

frame_number	!word 0
half_frame	!byte 0

process_a_frame:


	lda frame_number
	cmp #(TOTAL_FRAMES & $FF)
	bne .frames_left
	lda frame_number + 1
	cmp #(TOTAL_FRAMES >> 8)
	bne .frames_left
	sec
	rts

.frames_left:
	lda half_frame
	and #1
	bne process_a_frame_loop

	jsr sound

process_a_frame_loop2:
	JSR load_current_stripe
	BCS .end2
	JSR draw_a_stripe

;; !if compression != LZ {

	LDA #2
	+add_a_to_16 stripe_index
;; }
	; Reached the end of screen ?


	LDA hgr_current_line
	CMP #(VERTICAL_TILES / 2)
	BMI process_a_frame_loop2

	;; LDA #>(HGR_RAM + $2000)
	;; CMP screen_pointer+1
	;; BNE process_a_frame_loop2
	inc half_frame
.end2:
	rts
	;; jmp .end

process_a_frame_loop:
	JSR load_current_stripe
	BCS .end
	JSR draw_a_stripe

	LDA #2
	+add_a_to_16 stripe_index

	; Reached the end of screen ?

	LDA hgr_current_line
	CMP #(VERTICAL_TILES)
	BMI process_a_frame_loop

	;; LDA #>(HGR_RAM + $2000)
	;; CMP screen_pointer+1
	;; BNE process_a_frame_loop

	;;  Yep, reached. So we reset.

	LDA #0
	STA hgr_current_line
	+store_16 screen_pointer, HGR_RAM
	+setup_hgr_line_pointers

	inc half_frame
	+inc16 frame_number
.freeze:
	;; JMP .freeze

.end:
	RTS



; ----------------------------------------------------------------------------

load_current_stripe:
	!zone {

!if compression = LZ {
	jsr huff_pointer_at_end
} else {
	jsr check_stripe_at_end
}

	bcs .error



!if compression = LZ {
	jsr read_bits

	;; data contains the stripe *number*

	clc
	rol data
	rol data + 1
	lda data
	sta stripe_ptr
	lda data+1
	sta stripe_ptr+1

	;; stripe_ptr == stripe number * 2
} else {
	LDY #0
	LDA (stripe_index),Y
	STA stripe_ptr
	INY
	LDA (stripe_index),Y
	STA stripe_ptr + 1	; stripe_ptr = stripe_index* = number of the stripe * 2
}
	;; Debug code

;; 	jsr read_bits
;; 	clc
;; 	rol data
;; 	rol data + 1
;; 	lda data
;; 	cmp stripe_ptr
;; 	beq .zop
;; .zip
;; 	brk
;; .zop
;; 	lda data + 1
;; 	cmp stripe_ptr + 1
	;; 	bne .zip

;;  End debug code

	; Reached the end of stripes ? (stripe number $FFFF)

	LDA #$FF
	CMP stripe_ptr
	BNE .not_last_stripe
	CMP stripe_ptr + 1
	BNE .not_last_stripe

	; Stay stuck on end of stripes until someone moves us out.
.error
	SEC ; mark last
	RTS

.not_last_stripe:
	+add_const_to_16 stripe_ptr, stripes_indices	; stripe_ptr = stripe_indices + stripe_ptr = stripe_indices + number of the stripe * 2

	LDY #0
	LDA (stripe_ptr),Y
	STA cmd_pointer
	INY
	LDA (stripe_ptr),Y
	STA cmd_pointer + 1		; cmd_pointer = stripe_ptr* = stripe_indices[ number of stripe * 2]

	; So at this point cmd_pointer points to the stripe data.

	CLC	     ; mark we can go on
	RTS
	}

; -----------------------------------------------------------------------------

advance_stripe_pointer:
	!zone {

	; Go to next stripe

	LDA #2
	+add_a_to_16 stripe_index

	RTS
	}


; -----------------------------------------------------------------------------

x_save	!byte 0
y_save	!byte 0
a_save	!byte 0


!macro	hgr_fill {

	sta a_save
	stx x_save
	sty y_save

	ldx #8
	ldy #0
	clc
.loop:
	lda $F000,X
	sta ($F0),Y
	lda screen_pointer
	adc #$4
	sta screen_pointer
	dex
	bne .loop

	lda a_save
	ldx x_save
	ldy y_save

	}

; -----------------------------------------------------------------------------

draw_a_stripe:
	LDY #0									; 3 c
       	LDA (cmd_pointer),Y ; load command					; 4 c
	STA command_byte      	   						; 4 c

	CMP #128								; 2 c
	BPL tile_copy								; 2+ c
	BEQ tile_copy								; 2+ c

	;; 5D -> 0101 1101
       	AND #%11100000								; 2 c
       	CMP #%00000000								; 2 c
       	BEQ fill_white								; 2+ c
       	CMP #%00100000								; 2 c
       	BEQ fill_black								; 2+ c
       	CMP #%01000000								; 2 c
       	BEQ fill_transparent ;  2+ c

done_rle:
	RTS									; 6 c => total 37 +? 5

tile_copy:

	; FIXME reuse Acc from test above (it's acount)
  	TAX									; 2 c

	LDY #1	; peek one byte further.					; 2 c
	LDA (cmd_pointer),Y							; 4 c

	LDY #0	;From now on, Y is the screen pointer				; 2 c

	CMP #$FF      	      	       	      					; 2 c
	BNE two_tiles_at_least							; 2+ c

	; just one tile

	+inc16 cmd_pointer ; skip the $FF mark
	JMP last_tile_copy							; 3 c

two_tiles_at_least:
	; Copy the first tile
	; First tile is special case because it has a flag on it.

	TXA									; 2 c

	;; JSR tile_expand								; 6 c
	JSR hgr_tile_expander

	+inc16 cmd_pointer							; 12/15 c

tile_copy_loop:
	LDX #0									; 2 c
       	LDA (cmd_pointer,X) ; data byte	(in this case tile number)		; 6 c

	TAX		   ;  for later use ; 2 c
	AND #$80								; 2 c
	BNE last_tile_copy							; 2+ c

	TXA
	;; JSR tile_expand								; 6 c => 17 or 40
	JSR hgr_tile_expander

	+inc16 cmd_pointer							; 12/15 c
	JMP tile_copy_loop							; 4 => n * (28+ +6 +17/40 + 12/15) => n * (63 +? 26) for two_tiles_at_least

last_tile_copy:
	;; LDX #0									; 2 c
       	;; LDA (cmd_pointer,X) ; data byte	(in this case tile number)		; 6 c
	TXA        	; remember data byte2 c
	AND #127	    ; remove last tile flag				; 2 c

	;; JSR tile_expand	      	     	       					; 6 c
	JSR hgr_tile_expander
	+inc16 cmd_pointer							; 12/15

	;; TYA    									; 2 c
	;; +add_a_to_16 screen_pointer						; 16 c
	RTS	     								; 6 c


fill_white:
	LDX #$FF	; $22 = dark blue						; 2 c
	JMP fill_row_plus_byte	     							; 6 c

fill_black:
	LDX #$00	; $33 = purple
	JMP fill_row_plus_byte

fill_transparent:

	LDA command_byte   ; 3 c
	AND #%00011111	; How many bytes to copy (not counting the extra data byte)	; 2 c
	CLC 		      	   	    	      	       	   	      		; 2 c
	ADC #1 		; 0 based coutn to 1 based count (0 means 1 pixel)		; 2 c
	TAY		  	      	      	   	       				; 2 c

transpa_loop:

	sty y_save
	+advance_screen_pointers_right
	ldy y_save
	dey
       	BNE transpa_loop								; 2 or 3 c => loop total n*19-1 cycles
	jmp add_last_byte


	;; LDX #$0F	; green
	;; JMP add_last_byte




fill_row_plus_byte:

	; We'll write count white/black bytes plus and additional data byte.
	; count = 3
	; 0,1,2 => 0,1 2,3 4,5 => 0 .. count*2 -1

	LDA command_byte   ; 3 c
	AND #%00011111	; How many bytes to copy (not counting the extra data byte)	; 2 c
	CLC 		      	   	    	      	       	   	      		; 2 c
	ADC #1 		; 0 based coutn to 1 based count (0 means 1 pixel)		; 2 c
	;; ASL 		; counter * 2 because each tile is 2x2 pixels			; 2 c
	TAY		  	      	      	   	       				; 2 c

	TXA		; Remember the color						; 2 c => Total 12 cycles
fill_black_or_white:

	sty y_save
	JSR hgr_mono_tile_expander
	ldy y_save
	dey

	;; DEY										; 2 cycles
       	;; STA (screen_pointer),Y								; 6 cycles
	;; DEY 										; 2 c
       	;; STA (screen_pointer),Y								; 6 c

       	BNE fill_black_or_white								; 2 or 3 c => loop total n*19-1 cycles


add_last_byte:
	LDA command_byte								; 2 c
	AND #%00011111	; How many compressed bytes to load				; 2 c
	;; ASL 		; each compressed byte will give two bytes in video ram		; 2 c
	;; ADC #2		; (carry cleared by ASL because hi bit is always zero) 0-based							; 2 c

	;; +add_a_to_16 screen_pointer	      ; screen_pointer += counter + 1		; 16 c

	LDY #1										; 2 c
	LDA (cmd_pointer),Y	; Load data byte					; 5 c

	LDY #0 ; screen pointer is at right position					; 2 c
	;; JSR tile_expand		      	    						; 6 c + (17 or 40)
	JSR hgr_tile_expander

	;; LDA #2										; 2 c
	;; +add_a_to_16 screen_pointer	; skip the tile we've just written		; 16 c
	LDA #2										; 2 c
	+add_a_to_16 cmd_pointer	; Skip cmd byte and data byte			; 16 c
       	RTS	     			       	   	    	 			; 6 c => add_last_byte = 83 + (17 or 40)

											; fill_row_plus_one_byte : 12 + (n*19-1) + 83 + (17 or 40) = 111 + 19*n +? 23

; ------------------------------------------------------------------------------



;;  ---------------------------------------------------------------------

hgr_mono_tile_expander:
	!zone {

	STA hgr_self_mod + 1

	ldx #8			; Tile height
	ldy #0
hgr_tile_loop:
hgr_self_mod:
	lda #$FF		; 2 bytes load a line of the tile
	sta (screen_pointer),Y		; 2 bytes show it on the screen
	lda screen_pointer + 1		; 2 bytes update the screen pointer (hi byte)
	clc				; FIXME not needed
	adc #4			; 2 bytes to the next line
	sta screen_pointer + 1		; 2 bytes
	dex
	bne hgr_tile_loop
	;; +store_16 lo_hi_bits_reverse_ptr, lo_hi_bits_reverse

	SEC
	sbc #32			; revert tile bytes, then advance one tile to the right
	sta screen_pointer + 1

	+advance_screen_pointers_right

	LDA hgr_self_mod + 1

	rts
	}

;;  ---------------------------------------------------------------------

hgr_tile_expander:
	!zone {

	AND #$7F
	CMP #TRANSPARENT_TILE
	BEQ transparent

	ASL			; x 2
	TAX
	LDA tiles_hgr,X		; ...to tile pointer
	STA .hgr_self_mod + 1
	LDA tiles_hgr + 1,X
	STA .hgr_self_mod + 1 + 1

	ldx #8			; Tile height
	ldy #0
.hgr_tile_loop:
.hgr_self_mod:
	lda $FFFF,x		; 2 bytes load a line of the tile
	sta (screen_pointer),Y		; 2 bytes show it on the screen
	lda screen_pointer + 1		; 2 bytes update the screen pointer (hi byte)
	clc				; FIXME not needed
	adc #4			; 2 bytes
	sta screen_pointer + 1		; 2 bytes
	dex
	bne .hgr_tile_loop
	;; +store_16 lo_hi_bits_reverse_ptr, lo_hi_bits_reverse

	SEC
	sbc #32			; revert tile bytes, then advance one tile to the right
	sta screen_pointer + 1
transparent:
	+advance_screen_pointers_right
	}
	rts



tile_expand:
	AND #127	; A = tile number						; 2 c
	CMP #TRANSPARENT_TILE	      	   							; 2 c
	BEQ expand_transparent_tile							; 2+ c
	ASL ; A = tile index								; 2 c

	;; +hgr_fill
	;; +hgr_fill

	TAX   	       									; 2 c
	LDA tiles,X									; 5+ c
	STA (screen_pointer),Y								; 6
	INY 										; 2
	LDA tiles+1,X									; 5+
	STA (screen_pointer),Y								; 6
	INY 										; 2
	RTS										; 6 => tile expand = 40 cycles

expand_transparent_tile:
	INY										; 2
	INY										; 2
	RTS										; 6 => tile expand = 17 cycles


line_count !byte 0

;; dummy_data:
;; 	!fill 512,$39

;; show_frame:

;; 	lda #<dummy_data
;; 	sta tile_pointer
;; 	lda #>dummy_data
;; 	sta tile_pointer+1


;; 	; There will be 40x48/4 = 480 tiles => I need more than a register to iterate over them.
;; 	; Or I can work with rows of tiles.

;; 	+store_16 screen_pointer, GR_RAM

;; 	; screen_pointer_plus_one := screen_pointer + 1

;; 	clc
;; 	lda screen_pointer
;; 	adc #1
;; 	sta screen_pointer_plus_one
;; 	lda screen_pointer + 1
;; 	adc #0
;; 	sta screen_pointer_plus_one + 1

;; iterations  = 16

;; 	lda #(512/iterations)
;; 	sta line_count

;; .show_frame_line_loop:
;; 	!for tile_ndx, iterations {
;; 	!zone {
;; 	ldy #(tile_ndx-1)
;; 	lda (tile_pointer),y

;; 	; The tile number is coded on the 7th lo bits.
;; 	ASL										; 2 c
;; 	CMP #(TRANSPARENT_TILE*2)	      	   							; 2 c
;; 	BEQ .next_tile							; 2+ c

;; 	TAX   	       									; 2 c

;; 	LDY #((tile_ndx-1)*2)
;; 	LDA tiles,X									; 5+ c
;; 	STA (screen_pointer),Y								; 6
;; 	LDA tiles+1,X									; 5+
;; 	STA (screen_pointer_plus_one),Y								; 6
;; .next_tile
;; 	}}

;; 	dec line_count
;; 	beq show_frame_finish

;; 	+add_const_to_16 tile_pointer, iterations	; screen is 40*48 => 1960 pixles =>  980 bytes, but there are gaps : 1024 bytes. Tiles code 4 pixles per byte => 512 bytes
;; 	+add_const_to_16 screen_pointer, iterations*2
;; 	+add_const_to_16 screen_pointer_plus_one, iterations*2

;; 	jmp .show_frame_line_loop

;; show_frame_finish:
;; 	RTS										; 6 => tile expand = 17 cycles



; =============================================================================

println:
looppln:
        ldx   #0
	; The LDA will be self modified by the writeln macro
	; to point to the actual message.
println_self_mod:
	lda   $0000,x                    ;Get the next character
        cmp   #0                       ;End of the string?
        beq   donepln                     ;->Yes!

	clc
	adc #$80	; Convert ASCII to Apple character map
        jsr COUT                     ;Print it out

	+inc16 println_self_mod+1
        jmp looppln                     ;And continue printing
donepln:
	rts                            ;All finished!


; ------------------------------------------------------------------------------
set_hgr_mode:
	; set GR mode, full screen
	LDA $C053		; mix text and gfx (c052 = full text/gfx)
	LDA $C054
	LDA $C057
	LDA $C050 ; display graphics; last for cleaner mode change (according to Apple doc)
	RTS

set_gr_mode:
	; set GR mode, full screen
	LDA $C052
	LDA $C054
	LDA $C056
	LDA $C050 ; last for cleaner mode change (according to Apple doc)
	RTS

; =============================================================================

; A = color to fill

clear_screen:
	LDX #$FF
clear_screen1:
	STA GR_RAM,X
	STA GR_RAM+$100,X
	STA GR_RAM+$200,X
	STA GR_RAM+$300,X
	DEX
	CPX #$FF
	BNE clear_screen1
	RTS

clear_hgr:
	+store_16 screen_pointer, HGR_RAM + $2000
clear_hgr_loop:
	+dec16 screen_pointer

	LDA #0
	LDY #0
	STA (screen_pointer), Y


	lda #$20
	cmp screen_pointer + 1
	bne clear_hgr_loop
	lda #0
	cmp screen_pointer
	bne clear_hgr_loop

	RTS

; =============================================================================

copy_screen:
	LDX #0

copy_screen1:
	!for bank, 4 {
	!for part, 3 {
	LDA 2000 + 256*(bank-1) + 40*(part-1),X
	STA GR_RAM + 256*(bank-1) + 40*(part-1),X
	}
	}

	INX
	CPX #40
	BNE copy_screen1

; =============================================================================

clear_sectors:
	ldx #40
	lda #00
clear_sectors2:
	sta 2000,X
	dex
	BNE clear_sectors2
	sta 2000
	rts

; -----------------------------------------------------------------------------



; -----------------------------------------------------------------------------

old_sect	!byte 0
sectors_passed	!byte 0

; =============================================================================

init_disk_read:

	; Read first sector so we know the drive's head is on the first track.
	; I use prodos to do that 'cos it's much simpler

	LDA #1
	STA block_read
	LDA #0
	STA block_read + 1
	JSR MLI
	!byte $80	; Operation ($80=READ_BLOCK, $81=write)
	!word prodos_params	    ; $0E0C

	; ProDOS has done its job, we configure ourselves accordingly.

	LDA #SLOT_SELECT
	STA slotz
	LDA #0
	STA curtrk

	; Restart the motor

	ldx #SLOT_SELECT
!if DRIVE_SELECT = $80 {
	LDA DRV2_SLCT, X
}
	LDA MOTOR_ON, X

	RTS



; =============================================================================

	!align 255,0

make_pause:
	STA pause_count
make_pause2:
	LDA #$FF
make_pause1:
	SEC	; 2 cycles
	SBC #1	; 2 cycles
	BNE make_pause1	; 2 or 3 cycles => 255 * (2+2+3) = 1785 cycles, * 40 = 71400 cycles per frame => 71400 cycles out of 100000 (1/10 of second) => 70% free time !

	DEC pause_count	; 6 cycles
	BNE make_pause2 ; 2 or 3 cycles => 40*(6+3) = 400
no_pause:
	RTS

pause_count	!word 0



; LINE_OFFSET !word 1024,1152,1280,1408,1536,1664,1792,1920,1064,1192,1320,1448,1576,1704,1832,1960,1104,1232,1360,1488,1616,1744,1872,2000


	!source "prodos.a"


flag_4_bits	!byte 0
data		!word 0

;;  ---------------------------------------------------------------------------

huff_pointer_at_end:
	!zone {
	lda track_buffer
	eor #SECTORS_PER_TRACK
	clc
	adc #TRACK_DATA_BANK
	clc
	adc #SECTORS_PER_TRACK		; Last sector + 1 (ie one sector too far)
	cmp pointer + 1	; Hi byte of stripe index beacuse a sector is 256 bytes.
	beq .at_end
	CLC
	RTS
.at_end:
	SEC
	RTS
	}

;;  ---------------------------------------------------------------------------

read_a_byte:
	;; jsr huff_pointer_at_end
	;; bcs .the_end

	+inc16 pointer	; leave A,X,Y unchanged
	clc
.the_end:
	rts

;;  ---------------------------------------------------------------------------

shift_8_bits:
	!zone {
	; A = current byte

	ldy #0
	lda (pointer),Y
	tax
	lda flag_4_bits		; set zero
	beq pick_whole
pick_high_bits:

	;;  2 bytes : AB CD
	;;  shifting : B. .C
	;;  or'ing : BC

	txa	; affects flags
	asl
	asl
	asl
	asl
	sta count1
	jsr read_a_byte
	bcs .end		; byte not ready

	ldy #0
	lda (pointer),Y
	lsr
	lsr
	lsr
	lsr
	ora count1
	clc			; LSR alters carry
	rts
pick_whole:
	jsr read_a_byte
	txa
.end:
	rts
	}


shift_4_bits:
	!zone {
	ldy #0
	lda (pointer),Y
	; A = current byte

	;;  Pick the first 4 high bits
	tax
	lda flag_4_bits
	eor #1
	sta flag_4_bits
	beq .pick_low_bits
	txa	; affects flags
	lsr
	lsr
	lsr
	lsr
	clc			; LSR atlers query
	rts	; CHECK ensure always taken
.pick_low_bits
.advance_pointer
	jsr read_a_byte
	txa
	and #$F
	rts
	}

.byte_not_ready2:
	rts

read_bits:
	jsr shift_4_bits
	bcs .byte_not_ready2
	cmp #%1110
	bpl test_16_bits
	beq test_16_bits

	cmp #%1100
	bpl test_12_bits
	beq test_12_bits

	cmp #%1000
	bpl test_8_bits
	beq test_8_bits

lo_byte	= data
hi_byte	= data + 1
d1	= (1 << 3)
d2	= (1 << 6) + (d1)
d3	= (1 << 9) + (d2)

test_4_bits:
	ldy #0
	sty hi_byte

	and #%0111
	sta lo_byte
	rts

test_8_bits:
	ldy #0
	sty hi_byte

	and #%0011
	asl
	asl
	asl
	asl
	sta lo_byte
	jsr shift_4_bits
	bcs .byte_not_ready
	ora lo_byte

	clc
	adc #d1

	sta lo_byte
	rts

test_12_bits:
	;;  init with 12 bits
	and #%0001
	sta hi_byte

	jsr shift_8_bits
	bcs .byte_not_ready
	sta lo_byte

	+add_const_to_16 data, d2
	rts

test_16_bits:
	;;  init with 16 bits
	and #%0001
	asl
	asl
	asl
	asl
	sta hi_byte
	jsr shift_4_bits
	bcs .byte_not_ready
	ora hi_byte
	sta hi_byte

	jsr shift_8_bits
	bcs .byte_not_ready
	sta lo_byte

	+add_const_to_16 data, d3

.byte_not_ready:
	rts



; ----------------------------------------------------------------------------

	;; 150 BPM => *2 300 BPM => same frequency as disk speed => I play a sound every 16 sectors
sound_freq	!byte 0
pause	!byte 0
pitch	!byte 8

ndx_partition	!byte 0

	DO0 = 0
	DO_D0 = 1
	RE0 = 2
	RE_D0 = 3
	MI0 = 4
	FA0 = 5
	FA_D0 = 6
	SOL0 = 7
	SOL_D0 = 8
	LA0 = 9
	LA_D0 = 10
	SI0 = 11


	DO = 0 + 12
	DO_D = 1 + 12
	RE = 2 + 12
	RE_D = 3 + 12
	MI = 4 + 12
	FA = 5 + 12
	FA_D = 6 + 12
	SOL = 7 + 12
	SOL_D = 8 + 12
	LA = 9 + 12
	LA_D = 10 + 12
	SI = 11 + 12

	DO2 = 0 + 24
	DO_D2 = 1 + 24
	RE2 = 2 + 24
	RE_D2 = 3 + 24
	MI2 = 4 + 24
	FA2 = 5 + 24
	FA_D2 = 6 + 24
	SOL2 = 7 + 24
	SOL_D2 = 8 + 24
	LA2 = 9 + 24
	LA_D2 = 10 + 24
	SI2 = 11 + 24
	END_PARTITION = 254
	P = 255

partition:
	!byte MI,FA,SOL,LA,SI,DO
	!byte MI2,RE2,SI,SI,MI,MI
	!byte SI, SOL, FA, MI
	!byte MI,FA,SOL,LA,SI, SI
	!byte LA, SOL, FA, SI0, FA, SOL, FA, MI, RE, SOL
	!byte END_PARTITION

inner_loops !byte 218,206,195,183,173,163,154,145,137,129,122,115,109,103,97,91,86,81,77,72,68,64,61,57,54,51,48,45,43,40,38,36,34,32,30,28
outer_loops !byte 1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,4,4,4,4,5,5,5,6,6,6,7,7,8,8,9,9,10,11,11,12
sound_skip	!byte 0

sound:
	pha

	lda sound_skip
	clc
	adc #1
	and #3
	sta sound_skip
	bne .done

	ldx ndx_partition

	lda partition, x
	tax
	lda outer_loops, X	; 6
	clc
	LSR
	sta pause

outer_loop:
	lda inner_loops, X	; 6
	clc
	LSR
	tay

	LDA SPKR		; 4
pause_looop:
	lda inner_loops, X	; 6 pause
	lda inner_loops, X	; 6 pause
	lda inner_loops, X	; 6 pause
	lda inner_loops, X	; 6
	lda inner_loops, X	; 6
	dey			; 2
	bne pause_looop		; 3

	CLC
	LSR
	LSR
	LSR
	TAY

	LDA SPKR		; 4
pause_looop2:
	lda inner_loops, X	; 6 pause
	lda inner_loops, X	; 6 pause
	lda inner_loops, X	; 6 pause
	lda inner_loops, X	; 6
	lda inner_loops, X	; 6
	dey			; 2
	bne pause_looop2		; 3


	dec pause
	bne outer_loop

	lda ndx_partition
	clc
	adc #1
	STA ndx_partition
	tax
	lda partition, x
	cmp #END_PARTITION
	bne .done
	LDA #0
	STA ndx_partition

.done:
	pla
	rts


counter	!word end_compressed - compressed

copy_compressed:
	;;  Copy from the end to the beginning of buffer

	+store_16 pointer, end_compressed - 1
	+store_16 pointer2, disk_buffers_base+2*SECTORS_PER_TRACK*BYTES_PER_SECTOR - 1 + 3 ; +3 extra bytes
	ldy #0
.loop:
	lda (pointer),Y	; absolut,Y = 4+ cycles (ZP is +/- the same)
	sta (pointer2),Y ; abso,Y = 5 cycles; ZP = 4 cycles
	;;  DEY = 2, BNE = 3 when taken
	;;  with loop unrolling : 4+5+2 = 11 cycles / byte
	+dec16 pointer
	+dec16 pointer2
	+dec16 counter

	lda counter
	cmp #0
	bne .loop
	lda counter + 1
	cmp #0
	bne .loop

	+store_16 pointer, disk_buffers_base+2*SECTORS_PER_TRACK*BYTES_PER_SECTOR - 1 + 3 - (end_compressed - compressed) + 1


init_preload:
	; Current track buffer to read sectors to
	lda #0
	sta track_buffer

 	lda #SECTORS_PER_TRACK
 	sta sectors_to_read

	!zone {

	lda #0			; sector is marked as read
	ldy #0
.loop:
	sta track_status,y
	iny
	cpy #SECTORS_PER_TRACK
	bne .loop
	}


	!zone {

	lda #1			; sector is marked as read
.loop:
	sta track_status,y
	iny
	cpy #2*SECTORS_PER_TRACK
	bne .loop
	}
	rts


preload_sectors:
	!zone {
	LDA #SECTORS_PER_TRACK
	STA count1

.loop:
!if DRAW_STATUS = 1 {
	jsr draw_status
}
	ldx #SLOT_SELECT
	jsr rdadr16
	bcs .loop	 ; Cheap retry

	jsr read_sector_if_necessary

	DEC count1
	BNE .loop
	}
	RTS




	!text "DATADATA"
	*= $4000
msg	!byte    $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
   	!text    "----------------------------------------", $0D
   	!text    "BAD APPLE", $0D
	!text    "                        WIZ / IMPHOBIA !", $0D
	!text    $0D
	!text    $0D
	!text	 "GREETZ TO PL, SCORPIO, DARKNESS !", $0D
	!text    $0D
	!text    "THANKS TO ONSLAUGHT ON C64 FOR HAVING", $0D
	!text    "PUT THE BAR SO HIGH :-)", $0D
	!text    $0D
	!text    "CONTACT: SCHAMPAILLER@SKYNET.BE", $0D
	!text    $0D
	!text	 "THIS PROGRAM IS COVERED BY THE", $0D
	!text    "GNU GENERAL PUBLIC LICENSE VERSION 3", $0D
	!text    "SEE HTTPS://WWW.GNU.ORG/LICENSES", $0D
	!text	 "(C) 2019 S. CHAMPAILLER", $0D
	!text    $0D
   	!text    "----------------------------------------", $0D
	!text    "FLIP DISK AND HIT ENTER TO BEGIN...", $0D
        !byte    $00

	!src "data.a"


	;; !src "data.a"



compressed:
	;; !source "compressed.a"
end_compressed:
